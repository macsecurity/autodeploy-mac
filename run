#!/bin/zsh
source "${0:a:h}/.global"
[ -f "$RD_SCRIPTS_VIRTUALENV/bin/activate" ] && source "$RD_SCRIPTS_VIRTUALENV/bin/activate"

CURL_ERROR='missing requirement : curl'
PY_ERROR="python missing or incompatible\n\tHAVE     :: $(python --version)\n\tREQUIRED :: python>=3.9"
ZSH_WARNING='this script is written and tested only against zsh; compatibility may vary'

#####################################################################

[ $RD_SCRIPTS_ENV ] && ENV_FILE="$RD_SCRIPTS_ENV" || {
	[ $1 ] \
		&& { ENV_FILE="$1"; shift 1; } \
		|| ENV_FILE=$(echo -e 'dev\nprod\nlocal' | fzf ${FZF_OPTIONS[@]} --prompt 'Select an environment : ')
}

cd "${0:a:h}"
[ -f ".$ENV_FILE" ] && source ".$ENV_FILE" || { echo "No such environment '$ENV_FILE'"; exit 1; }

# [[ $ENV_FILE =~ ^prod$ ]] && grep -v yage <(uname -a) >/dev/null 2>&1 && {
# 	{ git fetch origin master 2>&1 \
# 		&& git rebase origin/master 2>&1 \
# 		|| {
# 			echo '\nERROR:unable to synchronize with origin/master'
# 			echo 'ERROR:you must be up-to-date with master to run scripts on production'
# 			exit 1
# 		} >&2
# 	} >/dev/null
# }

#####################################################################

GET_AVAILABLE_SCRIPTS() {
	# find . -mindepth 2 -type f -executable \
	# 	| sed 's/^\.\///' \
	# 	| grep -v '^js\/node_modules\|^\.git\|^logs\|^data\'
	# find . -type f
	find . -type f | grep -w setup
}

[ $1 ] && {
	SCRIPT_NAME=$(GET_AVAILABLE_SCRIPTS)
	for REGEX in $*; do SCRIPT_NAME=$(echo $SCRIPT_NAME | grep $REGEX); done

	[ ! $SCRIPT_NAME ] && {
		echo "No script found by name '$*'"
		exit 2
	}
	[[ $(echo $SCRIPT_NAME | wc -l) -eq 1 ]] || {
		SCRIPT_NAME=$(\
			echo $SCRIPT_NAME \
			| fzf ${FZF_OPTIONS[@]} --prompt "'$*' ambiguous. Choose one or C^c to cancel : "
		)
		[ ! $SCRIPT_NAME ] && exit 2
	}
} || {
    SCRIPT_NAME=$(\
		GET_AVAILABLE_SCRIPTS \
    	    | fzf ${FZF_OPTIONS[@]} --prompt 'Select a script : ' \
    );
    [ ! $SCRIPT_NAME ] && exit 2;
}

#####################################################################

TYPE=$(echo $SCRIPT_NAME | sed 's/\/.*//')
SCRIPT="./$SCRIPT_NAME"

[ ! -f $SCRIPT ] && { echo 'no such script exists'; exit 3; }
case $TYPE in
    curl )
        curl --version >/dev/null 2>&1 || { echo "$CURL_ERROR"; exit 1; }
        ;;
    py )
        python --version | grep -q '3.[9]' || { echo "$PY_ERROR"; exit 1; }
        SCRIPT="python -m $(echo $SCRIPT_NAME | sed "s/\//./g; s/\.py$//; s/\.\.//")"
        ;;
    js ) 
        node --version >/dev/null 2>&1 || { echo "$JS_ERROR"; exit 1; }
        ;;
    aws )
        zsh --version >/dev/null 2>&1 || { echo "$ZSH_WARNING"; }
        ;;
    * ) zsh --version >/dev/null 2>&1 || { echo "$ZSH_WARNING"; }
        ;;
esac

#####################################################################

[ ! -d ./logs ] && mkdir ./logs;
{
    echo '=================='
    echo "$SCRIPT_NAME :: $(date)"
    echo "configuration :: '$ENV_FILE'"
    echo '------------------'
    eval $SCRIPT
    echo '------------------'
} 2>&1 | tee --append "./logs/$(echo $SCRIPT_NAME | sed 's/^\.\///; s/\//\%/g').log"
